"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));
var _useEventCallback = _interopRequireDefault(require("@restart/hooks/useEventCallback"));
var _react = _interopRequireWildcard(require("react"));
var _tinyWarning = _interopRequireDefault(require("tiny-warning"));
var _useRouter = _interopRequireDefault(require("./useRouter"));
var _jsxRuntime = require("react/jsx-runtime");
const _excluded = ["as", "to", "activeClassName", "activeStyle", "activePropName", "match", "router", "exact", "onClick", "target", "children"];
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
// TODO: Try to type this & simplify those types in next breaking change.
const Link = /*#__PURE__*/(0, _react.forwardRef)((_ref, ref) => {
  let {
      as: Component = 'a',
      to,
      activeClassName,
      activeStyle,
      activePropName,
      match: propsMatch,
      router: propsRouter,
      exact = false,
      onClick,
      target,
      children
    } = _ref,
    props = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);
  const {
    router,
    match
  } = (0, _useRouter.default)() || {
    match: propsMatch,
    router: propsRouter
  };
  const handleClick = (0, _useEventCallback.default)(event => {
    if (onClick) {
      onClick(event);
    }

    // Don't do anything if the user's onClick handler prevented default.
    // Otherwise, let the browser handle the link with the computed href if the
    // event wasn't an unmodified left click, or if the link has a target other
    // than _self.
    if (event.defaultPrevented || event.metaKey || event.altKey || event.ctrlKey || event.shiftKey || event.button !== 0 || target && target !== '_self') {
      return;
    }
    event.preventDefault();

    // FIXME: When clicking on a link to the same location in the browser, the
    // actual becomes a replace rather than a push. We may want the same
    // handling â€“ perhaps implemented in the Farce protocol.
    router.push(to);
  });
  if (process.env.NODE_ENV !== "production" && typeof Component !== 'function') {
    for (const wrongPropName of ['component', 'Component']) {
      const wrongPropValue = props[wrongPropName];
      if (!wrongPropValue) {
        continue;
      }
      process.env.NODE_ENV !== "production" ? (0, _tinyWarning.default)(false, `Link to ${JSON.stringify(to)} with \`${wrongPropName}\` prop \`${wrongPropValue.displayName || wrongPropValue.name || 'UNKNOWN'}\` has an element type that is not a component. The expected prop for the link component is \`as\`.`) : void 0;
    }
  }
  const href = router.createHref(to);
  const childrenIsFunction = typeof children === 'function';
  if (childrenIsFunction || activeClassName || activeStyle || activePropName) {
    const toLocation = router.createLocation(to);
    const active = router.isActive(match, toLocation, {
      exact
    });
    if (childrenIsFunction) {
      const add = {
        href,
        active,
        onClick: handleClick
      };
      return children(add);
    }
    if (active) {
      if (activeClassName) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        props.className = props.className ? `${props.className} ${activeClassName}` : activeClassName;
      }
      if (activeStyle) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        props.style = Object.assign({}, props.style, activeStyle);
      }
    }
    if (activePropName) {
      props[activePropName] = active;
    }
  }
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(Component, Object.assign({}, props, {
    href: href,
    ref: ref,
    onClick: handleClick // This overrides props.onClick.
    ,
    children: children
  }));
});

// eslint-disable-next-line react/prefer-stateless-function
var _default = Link;
exports.default = _default;
module.exports = exports.default;