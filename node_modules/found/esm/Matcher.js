import { dequal } from 'dequal';
import warning from 'tiny-warning';
import pathToRegexp, { compile } from './pathToRegexp';
export default class Matcher {
  constructor(routeConfig, options = {}) {
    this.routeConfig = routeConfig;
    this.options = Object.assign({
      warnOnPotentialMissingIndexRoutes: true,
      warnOnPartiallyMatchedNamedRoutes: true
    }, options);
  }
  match({
    pathname
  }) {
    const matches = this.matchRoutes(this.routeConfig, pathname);
    if (!matches) {
      return null;
    }
    return this.makePayload(matches);
  }
  getRoutes({
    routeIndices
  }) {
    if (!routeIndices) {
      return null;
    }
    return this.getRoutesFromIndices(routeIndices, this.routeConfig);
  }
  joinPaths(basePath, path) {
    if (!path) {
      return basePath;
    }
    if (basePath.charAt(basePath.length - 1) === '/') {
      // eslint-disable-next-line no-param-reassign
      basePath = basePath.slice(0, -1);
    }
    return `${basePath}${this.getCanonicalPattern(path)}`;
  }
  isActive({
    location: matchLocation
  }, location, {
    exact = false
  } = {}) {
    return this.isPathnameActive(matchLocation.pathname, location.pathname, exact) && this.isQueryActive(matchLocation.query, location.query);
  }
  format(pattern, params) {
    return compile(pattern)(params);
  }
  matchRoutes(routeConfig, pathname) {
    for (let index = 0; index < routeConfig.length; ++index) {
      const route = routeConfig[index];
      const match = this.matchRoute(route, pathname);
      if (!match) {
        continue; // eslint-disable-line no-continue
      }

      const {
        params,
        remaining
      } = match;
      const {
        children
      } = route;
      if (children) {
        if (Array.isArray(children)) {
          const childMatches = this.matchRoutes(children, remaining);
          if (childMatches) {
            return [{
              index,
              params
            }, ...childMatches];
          }
          if (!remaining && route.allowAsIndex) {
            return [{
              index,
              params
            }];
          }
          if (this.options.warnOnPotentialMissingIndexRoutes) process.env.NODE_ENV !== "production" ? warning(remaining, `Route matching pathname "${pathname}" has child routes, but no index route causing it to 404.\n` + `If this is intended ignore this warning otherwise in order to resolve this route add \`index\` to the route object or add route with no \`path\` and a \`Component\` to it's \`children\`.\n` + 'This warning can be disabled by setting `warnOnPotentialMissingIndexRoutes` to `false` in the Matcher.') : void 0;
        } else {
          const groups = this.matchGroups(children, remaining, pathname);
          if (groups) {
            return [{
              index,
              params
            }, {
              groups
            }];
          }
        }
      }
      if (!remaining && !children) {
        return [{
          index,
          params
        }];
      }
    }
    return null;
  }
  matchRoute(route, pathname) {
    const routePath = route.path;
    if (!routePath) {
      return {
        params: {},
        remaining: pathname
      };
    }
    const pattern = this.getCanonicalPattern(routePath);
    const keys = [];
    const regexp = pathToRegexp(pattern, keys, {
      end: false
    });
    const match = regexp.exec(pathname);
    if (match === null) {
      return null;
    }
    const params = {};
    keys.forEach(({
      name
    }, index) => {
      const value = match[index + 1];
      params[name] = value && decodeURIComponent(value);
    });
    return {
      params,
      remaining: pathname.slice(match[0].length)
    };
  }
  matchGroups(routeGroups, pathname, parentPathname) {
    const groups = {};
    const failedGroups = [];
    const abortEarly = process.env.NODE_ENV === 'production' || !this.options.warnOnPartiallyMatchedNamedRoutes;
    for (const [groupName, routes] of Object.entries(routeGroups)) {
      const groupMatch = this.matchRoutes(routes, pathname);
      if (!groupMatch) {
        if (abortEarly) {
          return null;
        }
        failedGroups.push(groupName);
      } else {
        groups[groupName] = groupMatch;
      }
    }
    if (failedGroups.length) {
      process.env.NODE_ENV !== "production" ? warning(!this.options.warnOnPartiallyMatchedNamedRoutes, `Route matching pathname "${parentPathname}" only partially matched against its named child routes causing it to 404. ` + `The following named routes failed to match "${pathname}":\n\n` + `${failedGroups.join(', ')}\n\n` + `If this is intended ignore this warning, otherwise the unmatched groups may need at catch all route "path=(.*)?".\n` + 'This warning can be disabled by setting `warnOnPartiallyMatchedNamedRoutes` to `false` in the Matcher.') : void 0;
      return null;
    }
    return groups;
  }
  getCanonicalPattern(pattern) {
    return pattern.charAt(0) === '/' ? pattern : `/${pattern}`;
  }
  makePayload(matches) {
    const routeMatch = matches[0];
    if ('groups' in routeMatch) {
      process.env.NODE_ENV !== "production" ? warning(matches.length === 1, `Route match with groups ${Object.keys(routeMatch.groups).join(', ')} has children, which are ignored.`) : void 0;
      const groupRouteIndices = {};
      const routeParams = [];
      const _params = {};
      Object.entries(routeMatch.groups).forEach(([groupName, groupMatches]) => {
        const groupPayload = this.makePayload(groupMatches);

        // Retain the nested group structure for route indices so we can
        // reconstruct the element tree from flattened route elements.
        groupRouteIndices[groupName] = groupPayload.routeIndices;

        // Flatten route groups for route params matching getRoutesFromIndices
        // below.
        routeParams.push(...groupPayload.routeParams);

        // Just merge all the params depth-first; it's the easiest option.
        Object.assign(_params, groupPayload.params);
      });
      return {
        routeIndices: [groupRouteIndices],
        routeParams,
        params: _params
      };
    }
    const {
      index,
      params
    } = routeMatch;
    if (matches.length === 1) {
      return {
        routeIndices: [index],
        routeParams: [params],
        params
      };
    }
    const childPayload = this.makePayload(matches.slice(1));
    return {
      routeIndices: [index, ...childPayload.routeIndices],
      routeParams: [params, ...childPayload.routeParams],
      params: Object.assign({}, params, childPayload.params)
    };
  }
  getRoutesFromIndices(routeIndices, routeConfigOrGroups) {
    const routeIndex = routeIndices[0];
    if (typeof routeIndex === 'object') {
      // Flatten route groups to save resolvers from having to explicitly
      // handle them.
      const groupRoutes = [];
      for (const [groupName, groupRouteIndices] of Object.entries(routeIndex)) {
        groupRoutes.push(...this.getRoutesFromIndices(groupRouteIndices, routeConfigOrGroups[groupName]));
      }
      return groupRoutes;
    }
    const route = routeConfigOrGroups[routeIndex];
    if (routeIndices.length === 1) {
      return [route];
    }
    return [route, ...this.getRoutesFromIndices(routeIndices.slice(1), route.children)];
  }
  isPathnameActive(matchPathname, pathname, exact) {
    if (pathname === matchPathname) {
      return true;
    }
    if (exact) {
      // The above condition is necessary for an exact match.
      return false;
    }

    // Require that a partial match be followed by a path separator.
    const pathnameWithSeparator = pathname.slice(-1) !== '/' ? `${pathname}/` : pathname;

    // Can't use startsWith, as that requires a polyfill.
    return matchPathname.indexOf(pathnameWithSeparator) === 0;
  }
  isQueryActive(matchQuery, query) {
    if (!query) {
      return true;
    }
    return Object.entries(query).every(([key, value]) => Object.prototype.hasOwnProperty.call(matchQuery, key) ? dequal(matchQuery[key], value) : value === undefined);
  }
  replaceRouteConfig(routeConfig) {
    this.routeConfig = routeConfig;
  }
}