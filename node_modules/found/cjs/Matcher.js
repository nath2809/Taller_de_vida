"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _dequal = require("dequal");
var _tinyWarning = _interopRequireDefault(require("tiny-warning"));
var _pathToRegexp = _interopRequireWildcard(require("./pathToRegexp"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
class Matcher {
  constructor(routeConfig, options = {}) {
    this.routeConfig = routeConfig;
    this.options = Object.assign({
      warnOnPotentialMissingIndexRoutes: true,
      warnOnPartiallyMatchedNamedRoutes: true
    }, options);
  }
  match({
    pathname
  }) {
    const matches = this.matchRoutes(this.routeConfig, pathname);
    if (!matches) {
      return null;
    }
    return this.makePayload(matches);
  }
  getRoutes({
    routeIndices
  }) {
    if (!routeIndices) {
      return null;
    }
    return this.getRoutesFromIndices(routeIndices, this.routeConfig);
  }
  joinPaths(basePath, path) {
    if (!path) {
      return basePath;
    }
    if (basePath.charAt(basePath.length - 1) === '/') {
      // eslint-disable-next-line no-param-reassign
      basePath = basePath.slice(0, -1);
    }
    return `${basePath}${this.getCanonicalPattern(path)}`;
  }
  isActive({
    location: matchLocation
  }, location, {
    exact = false
  } = {}) {
    return this.isPathnameActive(matchLocation.pathname, location.pathname, exact) && this.isQueryActive(matchLocation.query, location.query);
  }
  format(pattern, params) {
    return (0, _pathToRegexp.compile)(pattern)(params);
  }
  matchRoutes(routeConfig, pathname) {
    for (let index = 0; index < routeConfig.length; ++index) {
      const route = routeConfig[index];
      const match = this.matchRoute(route, pathname);
      if (!match) {
        continue; // eslint-disable-line no-continue
      }

      const {
        params,
        remaining
      } = match;
      const {
        children
      } = route;
      if (children) {
        if (Array.isArray(children)) {
          const childMatches = this.matchRoutes(children, remaining);
          if (childMatches) {
            return [{
              index,
              params
            }, ...childMatches];
          }
          if (!remaining && route.allowAsIndex) {
            return [{
              index,
              params
            }];
          }
          if (this.options.warnOnPotentialMissingIndexRoutes) process.env.NODE_ENV !== "production" ? (0, _tinyWarning.default)(remaining, `Route matching pathname "${pathname}" has child routes, but no index route causing it to 404.\n` + `If this is intended ignore this warning otherwise in order to resolve this route add \`index\` to the route object or add route with no \`path\` and a \`Component\` to it's \`children\`.\n` + 'This warning can be disabled by setting `warnOnPotentialMissingIndexRoutes` to `false` in the Matcher.') : void 0;
        } else {
          const groups = this.matchGroups(children, remaining, pathname);
          if (groups) {
            return [{
              index,
              params
            }, {
              groups
            }];
          }
        }
      }
      if (!remaining && !children) {
        return [{
          index,
          params
        }];
      }
    }
    return null;
  }
  matchRoute(route, pathname) {
    const routePath = route.path;
    if (!routePath) {
      return {
        params: {},
        remaining: pathname
      };
    }
    const pattern = this.getCanonicalPattern(routePath);
    const keys = [];
    const regexp = (0, _pathToRegexp.default)(pattern, keys, {
      end: false
    });
    const match = regexp.exec(pathname);
    if (match === null) {
      return null;
    }
    const params = {};
    keys.forEach(({
      name
    }, index) => {
      const value = match[index + 1];
      params[name] = value && decodeURIComponent(value);
    });
    return {
      params,
      remaining: pathname.slice(match[0].length)
    };
  }
  matchGroups(routeGroups, pathname, parentPathname) {
    const groups = {};
    const failedGroups = [];
    const abortEarly = process.env.NODE_ENV === 'production' || !this.options.warnOnPartiallyMatchedNamedRoutes;
    for (const [groupName, routes] of Object.entries(routeGroups)) {
      const groupMatch = this.matchRoutes(routes, pathname);
      if (!groupMatch) {
        if (abortEarly) {
          return null;
        }
        failedGroups.push(groupName);
      } else {
        groups[groupName] = groupMatch;
      }
    }
    if (failedGroups.length) {
      process.env.NODE_ENV !== "production" ? (0, _tinyWarning.default)(!this.options.warnOnPartiallyMatchedNamedRoutes, `Route matching pathname "${parentPathname}" only partially matched against its named child routes causing it to 404. ` + `The following named routes failed to match "${pathname}":\n\n` + `${failedGroups.join(', ')}\n\n` + `If this is intended ignore this warning, otherwise the unmatched groups may need at catch all route "path=(.*)?".\n` + 'This warning can be disabled by setting `warnOnPartiallyMatchedNamedRoutes` to `false` in the Matcher.') : void 0;
      return null;
    }
    return groups;
  }
  getCanonicalPattern(pattern) {
    return pattern.charAt(0) === '/' ? pattern : `/${pattern}`;
  }
  makePayload(matches) {
    const routeMatch = matches[0];
    if ('groups' in routeMatch) {
      process.env.NODE_ENV !== "production" ? (0, _tinyWarning.default)(matches.length === 1, `Route match with groups ${Object.keys(routeMatch.groups).join(', ')} has children, which are ignored.`) : void 0;
      const groupRouteIndices = {};
      const routeParams = [];
      const _params = {};
      Object.entries(routeMatch.groups).forEach(([groupName, groupMatches]) => {
        const groupPayload = this.makePayload(groupMatches);

        // Retain the nested group structure for route indices so we can
        // reconstruct the element tree from flattened route elements.
        groupRouteIndices[groupName] = groupPayload.routeIndices;

        // Flatten route groups for route params matching getRoutesFromIndices
        // below.
        routeParams.push(...groupPayload.routeParams);

        // Just merge all the params depth-first; it's the easiest option.
        Object.assign(_params, groupPayload.params);
      });
      return {
        routeIndices: [groupRouteIndices],
        routeParams,
        params: _params
      };
    }
    const {
      index,
      params
    } = routeMatch;
    if (matches.length === 1) {
      return {
        routeIndices: [index],
        routeParams: [params],
        params
      };
    }
    const childPayload = this.makePayload(matches.slice(1));
    return {
      routeIndices: [index, ...childPayload.routeIndices],
      routeParams: [params, ...childPayload.routeParams],
      params: Object.assign({}, params, childPayload.params)
    };
  }
  getRoutesFromIndices(routeIndices, routeConfigOrGroups) {
    const routeIndex = routeIndices[0];
    if (typeof routeIndex === 'object') {
      // Flatten route groups to save resolvers from having to explicitly
      // handle them.
      const groupRoutes = [];
      for (const [groupName, groupRouteIndices] of Object.entries(routeIndex)) {
        groupRoutes.push(...this.getRoutesFromIndices(groupRouteIndices, routeConfigOrGroups[groupName]));
      }
      return groupRoutes;
    }
    const route = routeConfigOrGroups[routeIndex];
    if (routeIndices.length === 1) {
      return [route];
    }
    return [route, ...this.getRoutesFromIndices(routeIndices.slice(1), route.children)];
  }
  isPathnameActive(matchPathname, pathname, exact) {
    if (pathname === matchPathname) {
      return true;
    }
    if (exact) {
      // The above condition is necessary for an exact match.
      return false;
    }

    // Require that a partial match be followed by a path separator.
    const pathnameWithSeparator = pathname.slice(-1) !== '/' ? `${pathname}/` : pathname;

    // Can't use startsWith, as that requires a polyfill.
    return matchPathname.indexOf(pathnameWithSeparator) === 0;
  }
  isQueryActive(matchQuery, query) {
    if (!query) {
      return true;
    }
    return Object.entries(query).every(([key, value]) => Object.prototype.hasOwnProperty.call(matchQuery, key) ? (0, _dequal.dequal)(matchQuery[key], value) : value === undefined);
  }
  replaceRouteConfig(routeConfig) {
    this.routeConfig = routeConfig;
  }
}
exports.default = Matcher;
module.exports = exports.default;