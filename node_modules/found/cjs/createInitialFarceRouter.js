"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = createInitialFarceRouter;
var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));
var _createFarceRouter = _interopRequireDefault(require("./createFarceRouter"));
var _createFarceStore = _interopRequireDefault(require("./createFarceStore"));
var _getStoreRenderArgs = _interopRequireDefault(require("./getStoreRenderArgs"));
const _excluded = ["historyProtocol", "historyMiddlewares", "historyOptions", "routeConfig", "matchContext", "resolver"];
async function createInitialFarceRouter(_ref) {
  let {
      historyProtocol,
      historyMiddlewares,
      historyOptions,
      routeConfig,
      matchContext,
      resolver
    } = _ref,
    options = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);
  const store = (0, _createFarceStore.default)({
    historyProtocol,
    historyMiddlewares,
    historyOptions,
    routeConfig
  });
  const FarceRouterInstance = (0, _createFarceRouter.default)(Object.assign({}, options, {
    store
  }));

  // This intentionally doesn't handle RedirectExceptions, because those
  // shouldn't happen here anyway.
  const initialRenderArgs = await (0, _getStoreRenderArgs.default)({
    store,
    matchContext,
    resolver
  });

  // We own this FarceRouter, so it's safe to replace its default props.
  FarceRouterInstance.defaultProps = Object.assign({}, FarceRouterInstance.defaultProps, {
    matchContext,
    resolver,
    initialRenderArgs
  });
  return FarceRouterInstance;
}
module.exports = exports.default;