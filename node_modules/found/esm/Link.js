import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/esm/objectWithoutPropertiesLoose";
const _excluded = ["as", "to", "activeClassName", "activeStyle", "activePropName", "match", "router", "exact", "onClick", "target", "children"];
import useEventCallback from '@restart/hooks/useEventCallback';
import React, { forwardRef } from 'react';
import warning from 'tiny-warning';
import useRouter from './useRouter';

// TODO: Try to type this & simplify those types in next breaking change.
import { jsx as _jsx } from "react/jsx-runtime";
const Link = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
      as: Component = 'a',
      to,
      activeClassName,
      activeStyle,
      activePropName,
      match: propsMatch,
      router: propsRouter,
      exact = false,
      onClick,
      target,
      children
    } = _ref,
    props = _objectWithoutPropertiesLoose(_ref, _excluded);
  const {
    router,
    match
  } = useRouter() || {
    match: propsMatch,
    router: propsRouter
  };
  const handleClick = useEventCallback(event => {
    if (onClick) {
      onClick(event);
    }

    // Don't do anything if the user's onClick handler prevented default.
    // Otherwise, let the browser handle the link with the computed href if the
    // event wasn't an unmodified left click, or if the link has a target other
    // than _self.
    if (event.defaultPrevented || event.metaKey || event.altKey || event.ctrlKey || event.shiftKey || event.button !== 0 || target && target !== '_self') {
      return;
    }
    event.preventDefault();

    // FIXME: When clicking on a link to the same location in the browser, the
    // actual becomes a replace rather than a push. We may want the same
    // handling â€“ perhaps implemented in the Farce protocol.
    router.push(to);
  });
  if (process.env.NODE_ENV !== "production" && typeof Component !== 'function') {
    for (const wrongPropName of ['component', 'Component']) {
      const wrongPropValue = props[wrongPropName];
      if (!wrongPropValue) {
        continue;
      }
      process.env.NODE_ENV !== "production" ? warning(false, `Link to ${JSON.stringify(to)} with \`${wrongPropName}\` prop \`${wrongPropValue.displayName || wrongPropValue.name || 'UNKNOWN'}\` has an element type that is not a component. The expected prop for the link component is \`as\`.`) : void 0;
    }
  }
  const href = router.createHref(to);
  const childrenIsFunction = typeof children === 'function';
  if (childrenIsFunction || activeClassName || activeStyle || activePropName) {
    const toLocation = router.createLocation(to);
    const active = router.isActive(match, toLocation, {
      exact
    });
    if (childrenIsFunction) {
      const add = {
        href,
        active,
        onClick: handleClick
      };
      return children(add);
    }
    if (active) {
      if (activeClassName) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        props.className = props.className ? `${props.className} ${activeClassName}` : activeClassName;
      }
      if (activeStyle) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        props.style = Object.assign({}, props.style, activeStyle);
      }
    }
    if (activePropName) {
      props[activePropName] = active;
    }
  }
  return /*#__PURE__*/_jsx(Component, Object.assign({}, props, {
    href: href,
    ref: ref,
    onClick: handleClick // This overrides props.onClick.
    ,
    children: children
  }));
});

// eslint-disable-next-line react/prefer-stateless-function

export default Link;