function _asyncIterator(iterable) { var method, async, sync, retry = 2; for ("undefined" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) { if (async && null != (method = iterable[async])) return method.call(iterable); if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable)); async = "@@asyncIterator", sync = "@@iterator"; } throw new TypeError("Object is not async iterable"); }
function AsyncFromSyncIterator(s) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object.")); var done = r.done; return Promise.resolve(r.value).then(function (value) { return { value: value, done: done }; }); } return AsyncFromSyncIterator = function (s) { this.s = s, this.n = s.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function () { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, return: function (value) { var ret = this.s.return; return void 0 === ret ? Promise.resolve({ value: value, done: !0 }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments)); }, throw: function (value) { var thr = this.s.return; return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(s); }
import { dequal } from 'dequal';
import React from 'react';
import warning from 'tiny-warning';
import ActionTypes from './ActionTypes';
import RouterContext from './RouterContext';
import StaticContainer from './StaticContainer';
import createRender from './createRender';
import createStoreRouterObject from './createStoreRouterObject';
import resolveRenderArgs from './resolveRenderArgs';
import { jsx as _jsx } from "react/jsx-runtime";
export default function createBaseRouter({
  renderPending,
  renderReady,
  renderError,
  /**
   * The Router level render, is responsible for turning an array of route elements
   * into a single composed element that can be rendered by React.
   *
   * Turning:
   *
   * ```jsx
   * [<AppPage>, null, <ProductPage>, <ProductHistoryPage />]
   * ```
   * Into:
   *
   * ```jsx
   * <AppPage>
   *  <ProductPage>
   *    <ProductHistoryPage />
   *  </ProductPage>
   * </AppPage>
   * ```
   */
  render = createRender({
    renderPending,
    renderReady,
    renderError
  })
}) {
  class BaseRouter extends React.Component {
    constructor(props) {
      super(props);
      const {
        store,
        match,
        matchContext,
        resolver,
        initialRenderArgs
      } = props;
      this.router = createStoreRouterObject(store);
      this.state = {
        isInitialRender: true,
        match,
        matchContext,
        resolver,
        iteration: 0,
        routerContext: {
          router: this.router,
          match: initialRenderArgs || null
        },
        element: initialRenderArgs ? render(initialRenderArgs) : null
      };
      this.lastIteration = 0;
      this.pendingResolvedMatch = false;
      this.dispatchMatch = pendingMatch => {
        store.dispatch({
          type: ActionTypes.RESOLVE_MATCH,
          payload: pendingMatch
        });
      };
    }

    // We use componentDidMount and componentDidUpdate to resolve the match if
    //  needed because element resolution is asynchronous anyway, and this lets
    //  us not worry about setState not being available in the constructor, or
    //  about having to pass around nextProps.

    componentDidMount() {
      this.mounted = true;
      if (!this.props.initialRenderArgs) {
        this.resolveMatch();
      }
      if (process.env.NODE_ENV !== "production" && typeof window !== 'undefined') {
        /* eslint-env browser */
        /* eslint-disable no-underscore-dangle */
        if (window.__FOUND_HOT_RELOAD__) {
          process.env.NODE_ENV !== "production" ? warning(!window.__FOUND_REPLACE_ROUTE_CONFIG__, 'Replacing existing hot reloading hook. Do not render more than one router instance when using hot reloading.') : void 0;
          window.__FOUND_REPLACE_ROUTE_CONFIG__ = this.router.replaceRouteConfig;
        }
        /* eslint-enable no-underscore-dangle */
        /* eslint-env browser: false */
      }
    }

    static getDerivedStateFromProps({
      match,
      resolver,
      matchContext
    }, state) {
      if (state.isInitialRender) {
        return {
          isInitialRender: false
        };
      }
      if (match !== state.match || resolver !== state.resolver || !dequal(matchContext, state.matchContext)) {
        return {
          match,
          resolver,
          matchContext,
          iteration: state.iteration + 1
        };
      }
      return null;
    }
    componentDidUpdate() {
      if (this.state.iteration > this.lastIteration) {
        this.lastIteration = this.state.iteration;
        this.resolveMatch();
      }
    }
    componentWillUnmount() {
      this.mounted = false;
      if (process.env.NODE_ENV !== "production" && typeof window !== 'undefined') {
        /* eslint-env browser */
        /* eslint-disable no-underscore-dangle */
        if (window.__FOUND_HOT_RELOAD__) {
          delete window.__FOUND_REPLACE_ROUTE_CONFIG__;
        }
        /* eslint-enable no-underscore-dangle */
        /* eslint-env browser: false */
      }
    }

    async resolveMatch() {
      const pendingIteration = this.lastIteration;
      const pendingMatch = this.props.match;
      try {
        var _iteratorAbruptCompletion = false;
        var _didIteratorError = false;
        var _iteratorError;
        try {
          for (var _iterator = _asyncIterator(resolveRenderArgs(this.router,
            // TODO: this should be removed once resolveRenderArgs is in TS
            this.props)), _step; _iteratorAbruptCompletion = !(_step = await _iterator.next()).done; _iteratorAbruptCompletion = false) {
            const renderArgs = _step.value;
            // Don't do anything if we're resolving an outdated match.
            if (!this.mounted || this.lastIteration !== pendingIteration) {
              return;
            }

            // If we're about to mark the match resolved, delay the rerender
            //  until we do so.
            this.pendingResolvedMatch = !!((renderArgs.elements || renderArgs.error) && this.props.resolvedMatch !== pendingMatch);
            this.setState({
              routerContext: {
                router: this.router,
                match: renderArgs
              },
              element: render(renderArgs)
            });
            if (this.pendingResolvedMatch) {
              // If this is a new match, update the store, so we can rerender at
              //  the same time as all of the links and other components
              //  connected to the router state.
              this.pendingResolvedMatch = false;
              this.dispatchMatch(pendingMatch);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (_iteratorAbruptCompletion && _iterator.return != null) {
              await _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      } catch (e) {
        if (!this.mounted || this.lastIteration !== pendingIteration) {
          return;
        }
        if (e.isFoundRedirectException) {
          this.router.replace(e.location);
          return;
        }

        /* istanbul ignore next: paranoid guard */
        throw e;
      }
    }
    render() {
      const {
        iteration,
        routerContext,
        element
      } = this.state;

      // Don't rerender synchronously if we have another rerender coming.
      return /*#__PURE__*/_jsx(StaticContainer, {
        shouldUpdate: this.lastIteration === iteration && !this.pendingResolvedMatch,
        children: /*#__PURE__*/_jsx(RouterContext.Provider, {
          value: routerContext,
          children: element
        })
      });
    }
  }
  return BaseRouter;
}