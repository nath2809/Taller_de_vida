"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.RouterProvider = RouterProvider;
exports.getFarceResult = getFarceResult;
var _Actions = _interopRequireDefault(require("farce/Actions"));
var _ServerProtocol = _interopRequireDefault(require("farce/ServerProtocol"));
var _react = _interopRequireWildcard(require("react"));
var _RouterContext = _interopRequireDefault(require("./RouterContext"));
var _createFarceStore = _interopRequireDefault(require("./createFarceStore"));
var _createRender = _interopRequireDefault(require("./createRender"));
var _getStoreRenderArgs = _interopRequireDefault(require("./getStoreRenderArgs"));
var _resolver = _interopRequireDefault(require("./resolver"));
var _jsxRuntime = require("react/jsx-runtime");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function RouterProvider({
  renderArgs,
  children
}) {
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_RouterContext.default.Provider, {
    value: (0, _react.useMemo)(() => ({
      router: renderArgs.router,
      match: renderArgs
    }), [renderArgs]),
    children: children
  });
}
async function getFarceResult({
  url,
  historyMiddlewares,
  historyOptions,
  routeConfig,
  matchContext,
  resolver = _resolver.default,
  renderPending,
  renderReady,
  renderError,
  render = (0, _createRender.default)({
    renderPending,
    renderReady,
    renderError
  })
}) {
  const store = (0, _createFarceStore.default)({
    historyProtocol: new _ServerProtocol.default(url),
    historyMiddlewares,
    historyOptions,
    routeConfig
  });
  let renderArgs;
  try {
    renderArgs = await (0, _getStoreRenderArgs.default)({
      store,
      matchContext,
      resolver
    });
  } catch (e) {
    if (e.isFoundRedirectException) {
      // The store is not exposed to the user, so we need to build the redirect
      // URL here.
      return {
        status: e.status,
        redirect: {
          url: store.farce.createHref(e.location)
        }
      };
    }

    /* istanbul ignore next: paranoid guard */
    throw e;
  } finally {
    // This is a no-op with ServerProtocol, but it doesn't hurt.
    store.dispatch(_Actions.default.dispose());
  }
  return {
    status: 'error' in renderArgs && renderArgs.error ? renderArgs.error.status : 200,
    element: /*#__PURE__*/(0, _jsxRuntime.jsx)(RouterProvider, {
      renderArgs: renderArgs,
      children: render(renderArgs)
    })
  };
}