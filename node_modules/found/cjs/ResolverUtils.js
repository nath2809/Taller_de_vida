"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.accumulateRouteValues = accumulateRouteValues;
exports.checkResolved = checkResolved;
exports.getComponents = getComponents;
exports.getRouteMatches = getRouteMatches;
exports.getRouteValue = getRouteValue;
exports.getRouteValues = getRouteValues;
exports.isResolved = isResolved;
var _isPromise = _interopRequireDefault(require("is-promise"));
var _tinySetImmediate = require("tiny-set-immediate");
var _tinyWarning = _interopRequireDefault(require("tiny-warning"));
const UNRESOLVED = {};

/**
 * Detects a resolved Promise by racing a sentinel value with the promise.
 * If the sentinel returns first the promise is still pending.
 *
 * If the value is not a promise it's simply returned
 */
function checkResolved(value) {
  if (!(0, _isPromise.default)(value)) {
    return value;
  }
  const ret = Promise.race([value, new Promise(resolve => {
    (0, _tinySetImmediate.setImmediate)(resolve, UNRESOLVED);
  })]);
  return ret;
}
function isResolved(value) {
  return value !== UNRESOLVED;
}
function accumulateRouteValuesImpl(routeValues, routeIndices, callback, initialValue) {
  const accumulated = [];
  let value = initialValue;
  for (const routeIndex of routeIndices) {
    if (typeof routeIndex === 'object') {
      // eslint-disable-next-line no-loop-func
      Object.values(routeIndex).forEach(groupRouteIndices => {
        accumulated.push(...accumulateRouteValuesImpl(routeValues, groupRouteIndices, callback, value));
      });
    } else {
      value = callback(value, routeValues.shift());
      accumulated.push(value);
    }
  }
  return accumulated;
}
function accumulateRouteValues(routeValues, routeIndices,
// TODO: type this better
callback, initialValue) {
  return accumulateRouteValuesImpl([...routeValues], routeIndices, callback, initialValue);
}
function getRouteMatches(match) {
  return match.routes.map((route, i) => Object.assign({}, match, {
    route,
    routeParams: match.routeParams[i]
  }));
}
function getRouteValue(match, getGetter, getValue) {
  const {
    route
  } = match;
  const getter = getGetter(route);
  return getter ? getter.call(route, match) : getValue(route);
}

// This is a little more versatile than if we only passed in keys.
function getRouteValues(routeMatches, getGetter, getValue) {
  return routeMatches.map(match => getRouteValue(match, getGetter, getValue));
}
function getRouteGetComponent(route) {
  return route.getComponent;
}
function getRouteComponent(route) {
  if (process.env.NODE_ENV !== "production" && route.component) {
    process.env.NODE_ENV !== "production" ? (0, _tinyWarning.default)(route.Component, `Route with \`component\` property \`${route.component.displayName || route.component.name}\` has no \`Component\` property. The expected property for the route component is \`Component\`.`) : void 0;
  }
  return route.Component;
}

// This should be common to most resolvers, so make it available here.
function getComponents(routeMatches) {
  return getRouteValues(routeMatches, getRouteGetComponent, getRouteComponent);
}