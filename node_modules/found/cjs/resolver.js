"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _awaitAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/awaitAsyncGenerator"));
var _wrapAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapAsyncGenerator"));
var _isPromise = _interopRequireDefault(require("is-promise"));
var _ResolverUtils = require("./ResolverUtils");
var _createElements = _interopRequireDefault(require("./createElements"));
function getRouteGetData(route) {
  return route.getData;
}
function getRouteData(route) {
  return route.data;
}
var _default = {
  /**
   * `resolveElements` is responsible for converting a `match` into an
   * array of React `element`s. Rather than just returning an array,
   * it models all element/state updates for a match as an async iterable.
   *
   * This iterable will usually produce 2 values. The first being the "pending"
   * or loading states of the match. and the second being the final resolved set with data
   * and components being loaded fully. This second value is the "done" state for a match.
   *
   * If a match doesn't produce an element for every route, it yields `undefined` which
   * is interpreted by the `Router` as "continue to render the last UI while waiting
   * for the resolver to produce the final value", via a `StaticContainer`. This
   * is the default "loading" behavior and can be overriden by having `route.render`
   * produce any value but `undefined`.
   *
   * Generally though, routes will implement `render` which can implement a number of loading
   * strategies, either showing a spinner or skeleton UI while it waits for data to load.
   *
   * The iterable will produce only 1 value, if there is no async work to be done for the match.
   */
  resolveElements(match) {
    var _this = this;
    return (0, _wrapAsyncGenerator2.default)(function* () {
      const routeMatches = (0, _ResolverUtils.getRouteMatches)(match);
      const Components = (0, _ResolverUtils.getComponents)(routeMatches);
      const data = _this.getData(match, routeMatches);
      const earlyComponents = Components.some(_isPromise.default) ? yield (0, _awaitAsyncGenerator2.default)(Promise.all(Components.map(_ResolverUtils.checkResolved))) : Components;
      const earlyData = data.some(_isPromise.default) ? yield (0, _awaitAsyncGenerator2.default)(Promise.all(data.map(_ResolverUtils.checkResolved))) : data;
      let fetchedComponents;
      let fetchedData;
      if (!earlyComponents.every(_ResolverUtils.isResolved) || !earlyData.every(_ResolverUtils.isResolved)) {
        const pendingElements = (0, _createElements.default)(routeMatches, earlyComponents, earlyData);
        yield pendingElements.every(element => element !== undefined) ? pendingElements : undefined;
        fetchedComponents = yield (0, _awaitAsyncGenerator2.default)(Promise.all(Components));
        fetchedData = yield (0, _awaitAsyncGenerator2.default)(Promise.all(data));
      } else {
        fetchedComponents = earlyComponents;
        fetchedData = earlyData;
      }
      yield (0, _createElements.default)(routeMatches, fetchedComponents, fetchedData);
    })();
  },
  /**
   * Generate route data according to their getters, respecting the order of
   * promises per the `defer` flag on routes.
   *
   */
  // TODO: should this even be exported?
  getData(match, routeMatches) {
    return (0, _ResolverUtils.accumulateRouteValues)(routeMatches, match.routeIndices, ({
      ancestorRouteData,
      prevParentPromise
    }, routeMatch) => {
      // For a deferred route, the parent promise is the previous promise.
      // Otherwise, it's the previous parent promise.
      const parentPromise = routeMatch.route.defer ? Promise.all(ancestorRouteData) : prevParentPromise;

      // If there is a parent promise, execute after it resolves.
      const routeData = parentPromise ? parentPromise.then(() => (0, _ResolverUtils.getRouteValue)(routeMatch, getRouteGetData, getRouteData)) : (0, _ResolverUtils.getRouteValue)(routeMatch, getRouteGetData, getRouteData);
      return {
        routeData,
        ancestorRouteData: [...ancestorRouteData, routeData],
        prevParentPromise: parentPromise
      };
    }, {
      routeData: null,
      ancestorRouteData: [],
      prevParentPromise: null
    }).map(({
      routeData
    }) => routeData);
  }
};
exports.default = _default;
module.exports = exports.default;